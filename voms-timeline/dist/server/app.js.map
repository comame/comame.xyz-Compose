{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"path\"","webpack:///./src/server/dotenv.ts","webpack:///./src/server/app.ts","webpack:///external \"express\"","webpack:///external \"mongodb\"","webpack:///./src/server/websubExpressHandler.ts","webpack:///external \"crypto\"","webpack:///external \"fast-xml-parser\"","webpack:///external \"fs\"","webpack:///./src/config/channels.ts","webpack:///./src/server/fetchVideo.ts","webpack:///./src/API/YouTubeApiOptions/VideosAPIOptions.ts","webpack:///./src/server/fetch.ts","webpack:///external \"https\"","webpack:///./src/config/apiEndpoints.ts","webpack:///./src/util/urlQueryBuilder.ts","webpack:///./src/server/cache.ts","webpack:///./src/util/videoTime.ts","webpack:///./src/util/DateString.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","dotenv","fromEntries","readFileSync","resolve","__dirname","encoding","split","map","line","app","db","use","req","res","next","bodyText","on","chunk","toString","body","static","all","async","videoId","websubExpressHandler","video","fetchVideo","cacheResponse","data","collection","find","sort","time","limit","toArray","send","JSON","stringify","videos","lastUpdated","getCached","kind","items","Date","toISOString","MongoClient","connect","useUnifiedTopology","err","client","listen","console","log","queryObj","originalUrl","it","logRequest","subscribeObject","result","rawBody","insertOne","now","url","query","entries","replace","method","headers","channels","id","includes","challenge","sendStatus","validate","error","status","hmacKey","WEBSUB_HUB_SECRET","hmacDigest","createHmac","update","digest","requestedHmacDigest","header","slice","length","parse","updatedVideoId","feed","entry","options","part","GOOGLE_API_KEY","requestUrl","buildUrlQuery","join","fetch","json","isVideoAPIResponse","arg","option","Promise","reject","request","responseText","TextDecoder","decode","keys","Array","isArray","Response","statusCode","end","this","ok","text","youtube","search","activities","self","encodeURIComponent","filter","lastFetch","metadataCollection","metaUpdate","getTime","updateOne","upsert","videosCollection","_id","getVideoTime","item","cacheMetadata","findOne","liveStreamingDetails","actualEndTime","asDate","scheduledStartTime","snippet","publishedAt","dateString"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"path\");","import fs from 'fs'\nimport { resolve } from 'path'\n\nexport const dotenv: { [ key: string ]: string } = Object.fromEntries(\n    fs.readFileSync(resolve(__dirname, '../../.env'), {\n        encoding: 'utf8'\n    }).split('\\n').map(line => line.split('='))\n)\n","import path from 'path'\nimport express, { Response } from 'express'\nimport { MongoClient, Db } from 'mongodb'\nimport { websubExpressHandler } from './websubExpressHandler'\nimport { fetchVideo } from './fetchVideo'\nimport { cacheResponse, getCached } from './cache'\nimport { VideosResponse } from '../API/selfApiOptions/options'\n\nconst app = express()\nlet db: Db\n\n// Parse body as string\n// @ts-ignore: res unused\napp.use((req, res, next) => {\n    let bodyText = ''\n    req.on('data', (chunk: Buffer|string) => {\n        if (typeof chunk == 'string') {\n            bodyText += chunk\n        } else {\n            bodyText += chunk.toString('utf8')\n        }\n    })\n    req.on('end', () => {\n        req.body = bodyText\n        next()\n    })\n})\n\napp.get('**', express.static(path.resolve(__dirname, '../front')))\napp.all('/sub/hook', async (req, res) => {\n    const videoId = await websubExpressHandler(req, res, db)\n    if (!videoId) return\n    const video = await fetchVideo(videoId)\n    if (!video) return\n\n    await cacheResponse(db, [ video ])\n})\n\n// @ts-ignore: req unused\napp.get('/sub/logs', async (req, res) => {\n    const data = await db.collection('subs-log').find().sort({ time: -1 }).limit(100).toArray()\n    res.send(JSON.stringify(data, void 0, 2))\n})\n\n// @ts-ignore: req unused\napp.get('/api/videos', async (req, res: Response<VideosResponse>) => {\n    const { videos, lastUpdated } = await getCached(db)\n    res.send({\n        kind: 'voms-timeline.comame.xyz#videosResponse',\n        items: videos,\n        lastUpdated: new Date(lastUpdated).toISOString()\n    })\n})\n\nMongoClient.connect('mongodb://mongo:27017', { useUnifiedTopology: true }, (err, client) => {\n    if (err) throw err\n    db = client.db('voms-timeline')\n\n    app.listen(80, () => {\n        console.log('LISTEN')\n    })\n})\n","module.exports = require(\"express\");","module.exports = require(\"mongodb\");","import { Video } from '../API/YouTubeApiOptions/VideosAPIOptions'\nimport crypto from 'crypto'\nimport { Db } from 'mongodb';\nimport { parse as parseXml, validate as validateXml } from 'fast-xml-parser'\nimport { Request, Response } from 'express'\nimport { dotenv } from './dotenv'\nimport { channels } from '../config/channels'\n\nexport async function websubExpressHandler(req: Request, res: Response, db: Db): Promise<Video['id']|undefined> {\n    const queryObj = Object.fromEntries(req.originalUrl.split('?')[1]?.split('&').map(it => it.split('=')) ?? [])\n\n    const logRequest = async ( { queryObj, subscribeObject, result, rawBody = '' }: {\n        queryObj?: object,\n        subscribeObject?: object,\n        result: number,\n        rawBody?: string\n    }) => {\n        await db.collection('subs-log').insertOne({ time: Date.now(), req: {\n            url: req.originalUrl,\n            query: Object.fromEntries(Object.entries(queryObj ?? {}).map(it => {\n                return [ (it[0] as string).replace(/\\./g, '_'), it[1] ]\n            })),\n            method: req.method,\n            body: subscribeObject,\n            headers: req.headers,\n            result,\n            rawBody\n        } })\n    }\n\n    if (queryObj['hub.mode'] == 'subscribe') {\n        const acceptChannelIds = Object.entries(channels).map(it => it[1])\n        const acceptTopics = acceptChannelIds.map(id =>\n            ('https://www.youtube.com/xml/feeds/videos.xml?channel_id=' + id)\n                .replace(/\\?/g, '%3F')\n                .replace(/\\=/g, '%3D')\n        )\n\n        if (!acceptTopics.includes(queryObj['hub.topic'])) {\n            res.sendStatus(404)\n            await logRequest({ queryObj, result: 404 })\n        } else {\n            const challenge = queryObj['hub.challenge']\n            res.send(challenge)\n            await logRequest({ queryObj, result: 200 })\n        }\n        return\n    } else if (queryObj['hub.mode'] == 'unsubscribe') {\n        res.sendStatus(404)\n        await logRequest({ queryObj, result: 404 })\n        return\n    } else if (queryObj['hub.mode'] == 'denied') {\n        res.send()\n        await logRequest({ queryObj, result: 200 })\n        return\n    }\n\n    if (validateXml(req.body) !== true) {\n        const error = validateXml(req.body)\n        console.error('VALIDATE ERROR', error)\n        res.status(500).send('error')\n        await logRequest({ subscribeObject: req.body, result: 500, rawBody: req.body })\n        return\n    }\n\n    const hmacKey = dotenv.WEBSUB_HUB_SECRET\n    const hmacDigest = crypto.createHmac('sha1', hmacKey).update(req.body).digest('hex')\n    const requestedHmacDigest = req.header('x-hub-signature')?.slice('sha1='.length)\n\n    if (hmacDigest != requestedHmacDigest) {\n        console.error('Invalid digest request', 'wants: ' + hmacDigest, 'got: ' + requestedHmacDigest)\n        res.send('ok')\n        await logRequest({ subscribeObject: req.body, result: 200500, rawBody: req.body })\n        return\n    }\n\n    res.send('ok')\n\n    const subscribeObject = parseXml(req.body)\n    const updatedVideoId = subscribeObject.feed?.entry?.['yt:videoId'] as string | undefined\n\n    await logRequest({ subscribeObject, result: 200, rawBody: req.body })\n\n    return updatedVideoId\n}\n","module.exports = require(\"crypto\");","module.exports = require(\"fast-xml-parser\");","module.exports = require(\"fs\");","export const channels = {\n    '天野ピカミィ': 'UCajhBT4nMrg3DLS-bLL2RCg',\n    '緋笠トモシカ': 'UC3vzVK_N_SUVKqbX69L_X4g',\n    '磁富モノエ': 'UCaFhsCKSSS821N-EcWmPkUQ',\n}\n","import { VideoAPIOptions, Video, isVideoAPIResponse } from '../API/YouTubeApiOptions/VideosAPIOptions'\nimport { fetch } from './fetch'\nimport { youtube as endpoints } from '../config/apiEndpoints'\nimport { dotenv } from './dotenv'\nimport { buildUrlQuery } from '../util/urlQueryBuilder'\n\nexport async function fetchVideo(videoId: string): Promise<Video|undefined> {\n    const options: VideoAPIOptions = {\n        part: ['id', 'snippet', 'liveStreamingDetails' ],\n        id: videoId,\n        key: dotenv.GOOGLE_API_KEY\n    }\n    const requestUrl = buildUrlQuery(endpoints.videos, {\n        ...options,\n        part: options.part.join(',')\n    })\n\n    const res = await fetch(requestUrl)\n    const json = await res.json()\n\n    if (!isVideoAPIResponse(json)) {\n        throw 'ERROR'\n    }\n    return json.items[0]\n}\n","import { Thumbnails } from './Thumbnails'\nimport { DateString } from '../../util/DateString';\n\nexport interface VideoAPIOptions {\n    part: Array<'id'|'snippet'|'contentDetails'|'liveStreamingDetails'|'player'|'status'>\n    id: string\n    maxResults?: number\n    key?: string\n}\n\nexport interface VideoAPIResponse {\n    kind: 'youtube#videoListResponse'\n    etag: string\n    nextPageToken?: string\n    prevPageToken?: string\n    pageInfo: {\n        totalResults: number\n        resultsPerPage: number\n    }\n    items: Video[]\n}\n\nexport interface Video {\n    kind: 'youtube#video'\n    etag: string\n    id: string\n    snippet?: {\n        publishedAt: DateString\n        channelId: string\n        title: string\n        description: string\n        thumbnails: Thumbnails\n        channelTitle: string\n        liveBroadcastContent?: 'live'|'none'|'upcoming'\n    }\n    contentDetails?: {\n        duration: string\n    }\n    player?: {\n        embedHtml: string\n    }\n    liveStreamingDetails?: {\n        actualStartTime?: DateString\n        actualEndTime?: DateString\n        scheduledStartTime?: DateString\n    }\n}\n\nexport function isVideoAPIResponse(arg: any): arg is VideoAPIResponse {\n    return typeof arg == 'object' && arg.kind == 'youtube#videoListResponse'\n}\n","import https from 'https'\n\nexport interface HTTPHeaders {\n    [key: string]: string\n}\n\nexport interface FetchOptions {\n    method?: 'GET'\n    headers?: HTTPHeaders\n}\n\nexport async function fetch(url: string, option?: FetchOptions): Promise<Response> {\n    return new Promise((resolve, reject) => {\n        const req = https.request(url, option ?? {}, (res) => {\n            let responseText = ''\n\n            res.on('data', (chunk: Uint8Array | string) => {\n                if (typeof chunk == 'string') {\n                    responseText += chunk\n                } else {\n                    responseText += new TextDecoder('utf-8').decode(chunk)\n                }\n            })\n\n            res.on('end', () => {\n                const headers = {} as HTTPHeaders\n                for (const key of Object.keys(res.headers)) {\n                    const value: string | string[] | undefined = res.headers[key]\n                    if (typeof value == 'undefined') continue\n                    if (Array.isArray(value)) {\n                        headers[key] = value.join(' ')\n                        continue\n                    }\n                    headers[key] = value\n                }\n\n                resolve(new Response(\n                    headers,\n                    res.statusCode!!,\n                    res.url!!,\n                    responseText\n                ))\n            })\n        })\n\n        req.on('error', (err) => {\n            reject(err)\n        })\n\n        req.end()\n    })\n}\n\nexport class Response {\n    public ok: boolean\n    public json: () => Promise<{}>\n    public text: () => Promise<string>\n\n    constructor(\n        public headers: HTTPHeaders,\n        public status: number,\n        public url: string,\n        responseText: string\n    ){\n        if (200 <= status && status < 300) {\n            this.ok = true\n        } else {\n            this.ok = false\n        }\n\n        this.json = async () => JSON.parse(responseText)\n        this.text = async () => responseText\n    }\n}\n","module.exports = require(\"https\");","export const youtube = {\n    search: 'https://www.googleapis.com/youtube/v3/search',\n    activities: 'https://www.googleapis.com/youtube/v3/activities',\n    videos: 'https://www.googleapis.com/youtube/v3/videos'\n}\n\nexport const self = {\n    videos: '/api/videos'\n}\n","export interface URLQuery {\n    [ key: string ]: string|number|undefined\n}\n\nexport function buildUrlQuery(url: string, query: URLQuery) {\n    const queryString = Object.keys(query).map(key => {\n        const value = query[key]\n        if (typeof value == 'undefined') return\n        return encodeURIComponent(key) + '=' + encodeURIComponent(value)\n    }).filter(it =>\n        typeof it != 'undefined'\n    ).join('&')\n    return url + '?' + queryString\n}\n","import { Db, Collection } from 'mongodb'\nimport { Video } from \"../API/YouTubeApiOptions/VideosAPIOptions\";\nimport { getVideoTime } from '../util/videoTime';\n\ninterface CacheMeta {\n    lastUpdated: number,\n    lastFetch: number\n}\n\ninterface VideoCache {\n    _id: Video['id'],\n    time: number,\n    item: Video,\n    update: number\n}\n\nexport async function cacheResponse(db: Db, videos: Video[], lastFetch?: number) {\n    const metadataCollection: Collection<CacheMeta> = db.collection('metadata')\n\n    const metaUpdate = lastFetch ? {\n        lastUpdated: new Date().getTime(),\n        lastFetch\n    } : {\n        lastUpdated: new Date().getTime()\n    }\n\n    await metadataCollection.updateOne({}, {\n        '$set': metaUpdate\n    }, {\n        upsert: true\n    })\n\n    const videosCollection: Collection<VideoCache> = db.collection('videos')\n    await Promise.all(videos.map(video => videosCollection.updateOne({\n        _id: video.id\n    }, {\n        '$set': {\n            _id: video.id,\n            time: getVideoTime(video).getTime(),\n            item: video,\n            update: Date.now()\n        }\n    }, {\n        upsert: true\n    })))\n}\n\nexport async function getCached(db: Db, limit: number = 50): Promise<{\n    lastUpdated: number,\n    lastFetch: number,\n    videos: Video[]\n}> {\n    const metadataCollection: Collection<CacheMeta> = db.collection('metadata')\n    const videosCollection: Collection<VideoCache> = db.collection('videos')\n\n    const cacheMetadata = await metadataCollection.findOne({})\n    const videoCaches = await videosCollection.find()\n        .sort('time', -1)\n        .limit(limit)\n        .toArray()\n\n    const videos = videoCaches.map(it => it.item)\n    const lastUpdated = cacheMetadata?.lastUpdated ?? 0\n    const lastFetch = cacheMetadata?.lastFetch ?? 0\n\n    return { lastUpdated, lastFetch, videos }\n}\n","import { Video } from \"../API/YouTubeApiOptions/VideosAPIOptions\";\nimport { asDate } from \"./DateString\";\n\nexport function getVideoTime(video: Video): Date {\n    if (video.liveStreamingDetails?.actualEndTime) {\n        return asDate(video.liveStreamingDetails.actualEndTime)\n    }\n    if (video.liveStreamingDetails?.scheduledStartTime) {\n        return asDate(video.liveStreamingDetails.scheduledStartTime)\n    } else {\n        return asDate(video.snippet?.publishedAt!!)\n    }\n}\n","export type DateString = string\n\nexport function asDate(dateString: DateString): Date {\n    return new Date(dateString)\n}\n"],"sourceRoot":""}